# Copilot Instructions: Coffee Shop Queue System

## Architecture Overview

This is a serverless coffee shop order queue system built with:
- **AWS Lambda** functions for HTTP endpoints and SQS processing
- **MongoDB** for order persistence with status tracking
- **Amazon SQS** for asynchronous order processing with delays
- **Docker Compose** for local development with LocalStack

### Core Components

1. **`createOrder.js`**: HTTP POST endpoint that validates orders, stores in MongoDB, and queues for processing
2. **`processOrder.js`**: SQS-triggered function that advances orders through 3 stages with timed delays
3. **`database.js`**: Shared MongoDB utilities with connection pooling and CRUD operations

### Order Processing Flow

Orders progress through 4 states with automatic timing:
- `pending` → `grind coffee` (30s delay) → `percolate` (60s delay) → `done`

The system uses SQS DelaySeconds to schedule the next processing stage, creating a state machine pattern.

## Development Workflow

### Local Development (Recommended)
```bash
npm run docker:up-build  # Start all services with LocalStack
npm run docker:logs      # Monitor application logs
npm run docker:down      # Stop services
```

**Services:**
- API: http://localhost:3000
- Mongo Express: http://localhost:8081 (admin/admin)
- LocalStack SQS: http://localhost:4566

### Testing Orders
```bash
# Create order
curl -X POST http://localhost:3000/orders \
  -H "Content-Type: application/json" \
  -d '{"coffee_id":"esp001","description":"Espresso","value":3.50,"customerName":"Test"}'
```

## Code Patterns

### Environment Configuration
Both Lambda functions use this pattern for AWS SDK configuration:
```javascript
const sqsConfig = {
  region: process.env.AWS_REGION || 'us-east-1'
};

if (process.env.AWS_ENDPOINT_URL) {
  sqsConfig.endpoint = process.env.AWS_ENDPOINT_URL;  // LocalStack
  sqsConfig.accessKeyId = process.env.AWS_ACCESS_KEY_ID;
  sqsConfig.secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY;
}
```

### Database Connection Pattern
Use the singleton connection in `database.js`:
```javascript
const { createOrder, updateOrderStatus, getOrder } = require('../utils/database');
```

### Error Handling Convention
- HTTP functions return structured error responses with CORS headers
- SQS functions throw errors to trigger DLQ behavior
- All errors logged with `console.error()` for CloudWatch

## Key Files & Directories

- **`serverless.yml`**: Defines Lambda functions, SQS queue, and IAM permissions
- **`docker-compose.yml`**: Local dev environment with MongoDB, LocalStack, Mongo Express
- **`src/functions/`**: Lambda function handlers
- **`src/utils/database.js`**: MongoDB connection and operations
- **`docker/`**: Initialization scripts for LocalStack and MongoDB

## Deployment

- **Local**: `npm run docker:up-build` (uses LocalStack for SQS)
- **AWS**: `npm run deploy` (requires AWS credentials and environment variables)
- **Remove**: `npm run remove` (cleans up AWS resources)

### AWS Deployment Notes
- Requires `serverless-dotenv-plugin` to load `.env` variables during deployment
- Alternatively, export variables manually: `export $(cat .env | xargs) && npm run deploy`
- QUEUE_URL is automatically generated by CloudFormation, not read from .env

## Important Notes

- Order IDs use UUID v4 and serve as MongoDB `_id`
- SQS messages include `MessageAttributes` for orderId tracking
- MongoDB uses `coffee_shop` database with `orders` collection
- LocalStack requires specific initialization script for SQS queue creation
- Docker setup includes volume mounts for live development